<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Seong-Kook Shin's Little World (Posts about script)</title><link>http://www.cinsk.org/</link><description></description><atom:link href="http://www.cinsk.org/categories/script.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2018 &lt;a href="mailto:cinsky at gmail.com"&gt;Seong-Kook Shin&lt;/a&gt; </copyright><lastBuildDate>Tue, 06 Mar 2018 07:25:28 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Detect staled NFS mount</title><link>http://www.cinsk.org/posts/nfs-detect-stale/index.html</link><dc:creator>Seong-Kook Shin</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Check stale NFS&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Here's a simple script to check whether the given directory (NFS mount point)
is stale.
&lt;/p&gt;

&lt;script src="https://gist.github.com/cinsk/840ed553905cb6e8f0ae.js"&gt;⁠script&gt;

&lt;p&gt;
There are three points that needs some explanation here.
&lt;/p&gt;

&lt;p&gt;
First, since any command that access the NFS file system would block
(unresponsive) iff the NFS is stale, I am using &lt;code&gt;read -t N&lt;/code&gt; for the
timeout.
&lt;/p&gt;

&lt;p&gt;
Second, I used process substitution feature of bash, &lt;code&gt;&amp;lt;(list)&lt;/code&gt; form.
Basically, &lt;code&gt;read -t 1 &amp;lt; &amp;lt;(...)&lt;/code&gt; will timeout after 1 second unless
=⁠&amp;#x2026;= part finished within the timeout.  &lt;i&gt;bash&lt;/i&gt; will create a new
subshell to execute /⁠list/ in &lt;code&gt;&amp;lt;(list)&lt;/code&gt; form.  The problem is, if
any of &lt;i&gt;list&lt;/i&gt; will access the stale NFS, the command will hang,
which makes the subshell also will hang.  Even if the calling shell
script finished, the subshell would not terminated, leaving the
process in &lt;i&gt;interruptible sleep&lt;/i&gt; state.
&lt;/p&gt;

&lt;p&gt;
To prevent this, I recorded the sub-shell PID using &lt;code&gt;$BASHPID&lt;/code&gt; in
&lt;code&gt;&amp;lt;(list)&lt;/code&gt; form.  After =⁠read= command, I deleted all possible
children of the subshell and the subshell itself.  Note that using
&lt;code&gt;$$&lt;/code&gt; won't work in &lt;code&gt;&amp;lt;(list)&lt;/code&gt; form.  =⁠$$= represents the mother
shell's PID, not the sub-shell's.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;/script&gt;&lt;/div&gt;&lt;/div&gt;</description><category>nfs</category><category>script</category><category>stale</category><guid>http://www.cinsk.org/posts/nfs-detect-stale/index.html</guid><pubDate>Wed, 02 Jul 2014 08:00:00 GMT</pubDate></item><item><title>A script to create Redis Cluster using GNU screen(1)</title><link>http://www.cinsk.org/posts/screen-redis-replica/index.html</link><dc:creator>Seong-Kook Shin</dc:creator><description>&lt;p&gt;
Easy way to setup the local redis replication using GNU screen(1)
&lt;/p&gt;

&lt;p&gt;
One of my reponsibility is to write easy client library for Redis in C
and Java.  There are already well-known client C library, &lt;a href="https://github.com/redis/hiredis"&gt;hiredis&lt;/a&gt; and
Java library, &lt;a href="https://github.com/xetorthio/jedis"&gt;jedis&lt;/a&gt;.  At the time of development, none of these
support our Redis replication cluster.  I'll write later about the
client libraries that support replication.
&lt;/p&gt;

&lt;p&gt;
Anyway, during the development, I need to launch simple redis cluster,
which consists of 1 master and 2 slaves.  It is tiresome job to setup
the configuration of master and slaves, and it is very likely to
commit a mistake.
&lt;/p&gt;

&lt;p&gt;
Thus, I wrote a small shell script (called &lt;code&gt;redis-replica.sh&lt;/code&gt;) to
launch redis cluster locally.  Internally, it uses &lt;a href="https://www.gnu.org/software/screen/"&gt;GNU screen&lt;/a&gt; to
create multiple shell to launch required processes:
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="right"&gt;

&lt;col class="left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="right"&gt;shell no.&lt;/th&gt;
&lt;th scope="col" class="left"&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="left"&gt;&lt;i&gt;redis-sentinel&lt;/i&gt;, listening 26379&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="left"&gt;redis monitor to the sentinel&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;td class="left"&gt;&lt;i&gt;redis-cli&lt;/i&gt; to the sentinel&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;td class="left"&gt;&lt;i&gt;redis-server&lt;/i&gt; master, listening 6379&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;td class="left"&gt;redis monitor to the master&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;5&lt;/td&gt;
&lt;td class="left"&gt;&lt;i&gt;redis-cli&lt;/i&gt; to the master&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;6&lt;/td&gt;
&lt;td class="left"&gt;&lt;i&gt;redis-server&lt;/i&gt; slave#1, listening 6380&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;7&lt;/td&gt;
&lt;td class="left"&gt;redis monitor to the slave#1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;8&lt;/td&gt;
&lt;td class="left"&gt;&lt;i&gt;redis-cli&lt;/i&gt; to the slave#1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;9&lt;/td&gt;
&lt;td class="left"&gt;&lt;i&gt;redis-server&lt;/i&gt; slave#2, listening 6381&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;10&lt;/td&gt;
&lt;td class="left"&gt;redis monitor to the slave#2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;11&lt;/td&gt;
&lt;td class="left"&gt;&lt;i&gt;redis-cli&lt;/i&gt; to the slave#2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Since the master and slaves are managed by the &lt;i&gt;sentinel&lt;/i&gt; process, if
you shutdown the master, one of the slaves will be promoted to new
master.
&lt;/p&gt;

&lt;p&gt;
This way, you can easily experiment and test your client software or
libraries.
&lt;/p&gt;

&lt;p&gt;
Here is the source code of &lt;code&gt;redis-replica.sh&lt;/code&gt;:
&lt;/p&gt;

&lt;script src="http://gist-it.appspot.com/github/cinsk/snippets/blob/master/redis-replica.sh"&gt;&lt;/script&gt;</description><category>cluster</category><category>redis</category><category>replica</category><category>screen</category><category>script</category><category>sentinel</category><guid>http://www.cinsk.org/posts/screen-redis-replica/index.html</guid><pubDate>Fri, 22 Nov 2013 08:00:00 GMT</pubDate></item></channel></rss>