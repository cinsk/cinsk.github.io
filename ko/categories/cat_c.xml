<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Seong-Kook Shin's Little World (c에 대한 포스트)</title><link>http://www.cinsk.org/</link><description></description><atom:link href="http://www.cinsk.org/ko/categories/cat_c.xml" rel="self" type="application/rss+xml"></atom:link><language>ko</language><copyright>Contents © 2018 &lt;a href="mailto:cinsky at gmail.com"&gt;Seong-Kook Shin&lt;/a&gt; </copyright><lastBuildDate>Tue, 06 Mar 2018 08:00:16 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>A dirty macro that convert the scala type to string type in binary representation</title><link>http://www.cinsk.org/ko/posts/c-macro-convert-to-string/index.html</link><dc:creator>Seong-Kook Shin</dc:creator><description>&lt;p&gt;
Handy function that convert the scala type to string type in C.
This is a not-portable GCC macro to produce binary-represented string
in C or C++.
&lt;/p&gt;

&lt;p&gt;
Sometimes, it is useful to have a way to print a scala value in a binary
representation.  Unfortunately, there is no such format specifier for
&lt;code&gt;printf(3)&lt;/code&gt;.  Luckily, &lt;i&gt;glibc&lt;/i&gt; has a customization feature for &lt;code&gt;printf(3)&lt;/code&gt;-like
functions.  If you're interested in, read the code &lt;a href="https://github.com/cinsk/snippets/blob/master/printfb.c"&gt;here&lt;/a&gt;.  For example,
you could write:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xdeadbeef&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%b&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="cm"&gt;/* print 11011110101011011011111011101111 */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
If you're not using &lt;i&gt;glibc&lt;/i&gt;, you could create some utility functions to
do this.  Here're some candidate function prototypes:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* return the binary represented string of VALUE.  The width&lt;/span&gt;
&lt;span class="cm"&gt; * of the string is CHAR_BIT * size.  The return value should&lt;/span&gt;
&lt;span class="cm"&gt; * be free(3)ed after use. */&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;binstr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* store the binary representation of VALUE in string pointed by BUF&lt;/span&gt;
&lt;span class="cm"&gt; * with the size SIZE.  */&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;binstr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
I'm not satisfied with these.  The first one, which returns a value
that is dynamically allocated, looks heavy.  Plus, the caller should
supply the number of binary digit, since it always accept the value as
&lt;code&gt;unsigned long long&lt;/code&gt;.  The second one, which works only when the user
provided the buffer as in the second and the third parameters.  It
does not look heavy, but probably someone may be not happy with it,
since the user always need to prepare the buffer.
&lt;/p&gt;

&lt;p&gt;
I couldn't come up with a &lt;i&gt;everybody-satisified&lt;/i&gt; solution with this.
&lt;/p&gt;

&lt;p&gt;
Since most of my works are done in Linux and MacOS; both provides GCC,
so I decided to drop the portability. :)  
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define binstr(x)       ({ char *p = alloca(sizeof(x) * CHAR_BIT + 1);  \&lt;/span&gt;
&lt;span class="cp"&gt;      char *q = p + sizeof(x) * CHAR_BIT;                               \&lt;/span&gt;
&lt;span class="cp"&gt;      *q-- = '\0';                                                      \&lt;/span&gt;
&lt;span class="cp"&gt;      int i;                                                            \&lt;/span&gt;
&lt;span class="cp"&gt;      typeof(x) tmp = (x);                                              \&lt;/span&gt;
&lt;span class="cp"&gt;      for (i = 0; i &amp;lt; sizeof(x) * CHAR_BIT; i++) {                      \&lt;/span&gt;
&lt;span class="cp"&gt;	*q-- = (tmp &amp;amp; 1) ? '1' : '0';                                   \&lt;/span&gt;
&lt;span class="cp"&gt;	tmp &amp;gt;&amp;gt;= 1;                                                      \&lt;/span&gt;
&lt;span class="cp"&gt;      }                                                                 \&lt;/span&gt;
&lt;span class="cp"&gt;      q + 1;                                                            \&lt;/span&gt;
&lt;span class="cp"&gt;    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;I'm using &lt;code&gt;alloca(3)&lt;/code&gt;, instead of &lt;code&gt;malloc(3)&lt;/code&gt;, so that the memory
buffer should be freed automatically.  The caller no longer need to
call &lt;code&gt;free(3)&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;To decide the right number of digits of the value type, binstr is a
macro function.
&lt;/li&gt;
&lt;li&gt;I used &lt;i&gt;statement expression&lt;/i&gt;, ({…}) (GCC extension), which allows
me to declare local variables.
&lt;/li&gt;
&lt;li&gt;I used &lt;i&gt;typeof&lt;/i&gt; operator (GCC extension), which allows to declare a
local variable, that has the same type as the parameter.
&lt;/li&gt;
&lt;/ul&gt;</description><guid>http://www.cinsk.org/ko/posts/c-macro-convert-to-string/index.html</guid><pubDate>Thu, 26 Sep 2013 08:00:00 GMT</pubDate></item><item><title>Introduction of GNU obstack</title><link>http://www.cinsk.org/ko/posts/c-obstack/index.html</link><dc:creator>Seong-Kook Shin</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Obstack 소개&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Obstack은 Object Stack의 약자로서, 일종의 small memory
allocator입니다. 대개의 C/C++ 책을 보면, 작은 크기의 메모리를 여러번
할당할 필요가 있을 경우, &lt;code&gt;malloc(3)&lt;/code&gt;⁠이나 new operator를 직접 쓰는
것보다, 따로 메모리 할당 루틴을 만들어 쓰는 기법을 소개하곤
합니다. 물론 잘 만들면 좀 더 나은 성능을 가진 small memory allocator를
만들 수 있겠지만, 이미 GNU C library에 포함되어 있기 때문에, obstack을
쓰는 것이 좀 더 현명한 선택이 될 수 있습니다. (Why reinvent the
wheel?)
&lt;/p&gt;

&lt;p&gt;
Obstack은 GNU C library에 포함되어 있습니다. 좀 더 정확히 말하면, GNU
libiberty library에 포함되어 있으며, 이 libiberty library는 GNU C
library나 GCC, GDB 등의 소스에 포함되어 있는 라이브러리입니다. 필요한
소스는 단지 &lt;code&gt;obstack.h&lt;/code&gt;⁠와 &lt;code&gt;obstack.c&lt;/code&gt;⁠이기 때문에, GNU system이 아닌 다른
시스템에 포팅하기도 매우 쉽습니다.
&lt;/p&gt;

&lt;p&gt;
글쓴이의 개인적인 경험을 바탕으로 말하자면, Obstack은 매우 이식성이
높습니다. 글쓴이는 obstack을 Windows, DOS(Turbo C 2.0), vxworks,
psos등에 포팅한 경험을 갖고 있으며, 이 때, 소스 수정은 거의
필요없었습니다. 또한 시스템이 제공하는 memory allocator가 매우 느릴
경우, 또는 overhead가 클 경우등의 상황에서 obstack을 써서 큰 효과를
보았습니다.
&lt;/p&gt;

&lt;p&gt;
GNU obstack은 &lt;code&gt;malloc(3)&lt;/code&gt;⁠과 다른 여러 특징을 가지는데, 크게 요약하면
다음과 같습니다:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;memory를 (블럭 단위로) 미리 할당해 놓고, 사용자가 요청할 때 그 블럭의
일부분을 쪼개어 그 일부분을 제공합니다. 따라서 &lt;code&gt;malloc(3)&lt;/code&gt;⁠에 비해, 함수
호출에 대한 overhead가 무척 작습니다.
&lt;/li&gt;
&lt;li&gt;obstack을 써서 할당한 메모리는 이름을 보면 알 수 있듯이, stack 형태로
할당됩니다. 그리고, 기존에 할당되어 있던 메모리를 해제하면, 그 이후에
할당했던 메모리는 자동으로 해제됩니다. 따라서, obstack을 써서 N 번
메모리를 할당했을 경우, 맨 처음에 할당받은 메모리를 해제(free)하게
되면, N개의 메모리 블럭이 모두 해제(free)됩니다.
&lt;/li&gt;
&lt;li&gt;obstack의 growing object 기능을 쓰면, 메모리를 단계적으로 할당할 수
있습니다. 예를 들어, 한 object의 크기를 필요에 따라 조금씩 줄이거나
늘려 할당한 다음, 마지막에 완전히 크기가 결정되었을때 최종 메모리
크기를 결정할 수 있습니다.
&lt;/li&gt;
&lt;li&gt;obstack의 대부분 기능은 매크로 형태로 제공되기 때문에, 매우
빠릅니다.
&lt;/li&gt;
&lt;li&gt;한가지 단점은, obstack이 내부적으로 일정한 memory block을 할당해서
나눠주기 때문에, 개발자가 주의하지 않을 경우, 메모리 블럭이 망가질
가능성이 있다는 것입니다. 이런 경우, efence와 같은 메모리 디버깅
라이브러리는 큰 도움을 주지 못합니다.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;Obstack 써보기&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Obstack을 쓰기 위해서는, 먼저 기본적인 memory allocator를 알려 주어야
합니다. 개발자는 매크로 &lt;code&gt;obstack_chunk_alloc&lt;/code&gt;⁠과 &lt;code&gt;obstack_chunk_free&lt;/code&gt;⁠를 각각
정의해주어야 하는데, 간단히 다음과 같이 써 주면 됩니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define obstack_chunk_alloc malloc&lt;/span&gt;
&lt;span class="cp"&gt;#define obstack_chunk_free  free&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
물론, obstack 헤더 파일을 포함하는 코드도 써 주어야 할 것입니다 (위
매크로 정의와 &lt;code&gt;#include&lt;/code&gt;⁠의 순서는 상관 없습니다):
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;obstack.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
일단 위와 같이 환경 설정이 끝났다면, 이제 obstack을 하나 만들어야
합니다. (상황에 따라 여러 개 만들 수도 있습니다.) obstack을 만드는
대표적인 함수는 &lt;code&gt;obstack_init()&lt;/code&gt;⁠입니다. 다음과 같이 obstack을 만들 수
있습니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;obstack_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;obstack_init()&lt;/code&gt;⁠은 내부적으로 메모리 블럭을 하나 만들고, 기타 초기 설정을
마치는 함수입니다. 만약 &lt;code&gt;obstack_init()&lt;/code&gt;⁠이 실패했을 경우, 전역 변수인
&lt;code&gt;obstack_alloc_failed_handler&lt;/code&gt;⁠에 저장된 함수 포인터를 호출해서 에러
상황을 알리게 됩니다. 개발자가 특별히 이 변수에 에러 처리 함수를
등록하지 않았다면, 기본적으로 에러를 출력하고 프로그램을 종료하게
됩니다.
&lt;/p&gt;

&lt;p&gt;
주어진 obstack에 메모리를 할당하는 함수는 여러개가 존재합니다. 이 중
가장 대표적인 함수는 &lt;code&gt;obstack_alloc()&lt;/code&gt;⁠이며, &lt;code&gt;malloc(3)&lt;/code&gt;⁠과 같은 기능을
한다고 생각하시면 됩니다. 예를 들어, 문자열을 복사하는 함수인
&lt;code&gt;strdup()&lt;/code&gt;⁠과 비슷한 함수를 다음과 같이 만들 수 있습니다 (아래 코드는 GNU
C Library Manual에서 인용한 것입니다):
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obtsack&lt;/span&gt; &lt;span class="n"&gt;string_obstack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;copystring&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;obstack_alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;string_obstack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
이 외에도 다양한 할당 함수가 제공됩니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* SIZE              , ADDRESS                         .&lt;/span&gt;
&lt;span class="cm"&gt; *            ,                      . */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;obstack_copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ADDRESS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* obstack_copy()       , SIZE + 1                     &lt;/span&gt;
&lt;span class="cm"&gt; * '\0'               .                             . */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;obstack_copy0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ADDRESS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
앞에서도 잠깐 이야기했지만, obstack에 있는 메모리를 해제(free)하는
것은, &lt;code&gt;malloc(3)&lt;/code&gt;⁠ … &lt;code&gt;free(3)&lt;/code&gt;⁠와 좀 다르게 동작합니다.  일단 메모리를
해제하는 함수는 &lt;code&gt;obstack_free()&lt;/code&gt;⁠입니다.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;obstack_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBJECT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
이 함수는 주어진 obstack에 있는 OBJECT와, 이 OBJECT 이후에 할당한 모든
메모리를 해제합니다. 만약 OBJECT 파라메터에 &lt;code&gt;NULL&lt;/code&gt;⁠을 주면, 이 obstack에
할당된 모든 OBJECT가 해제(free)되며, 이 obstack은 더이상 쓸 수 없는
상태가 됩니다. 따라서 모든 메모리를 해제하면서, 동시에 이 obstack을
나중에 다시 쓰기 위해서는, 이 obstack에 맨 처음 할당했던 메모리 주소를
기억해 두었다가 OBJECT 파라메터에 전달해야 합니다.
&lt;/p&gt;

&lt;p&gt;
예를 들어, 포인터 A, B, C가 있고, 각각 메모리를 10, 100, 1000 바이트씩
순서대로 할당해서 썼다고 가정해 봅시다. 이 때 이 모든 메모리를 해제하기
위해서는 다음과 같이 호출하면 됩니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="n"&gt;my_stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;obstack_alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;my_stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;obstack_alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;my_stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;obstack_alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;my_stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* ... */&lt;/span&gt;
&lt;span class="n"&gt;obstack_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;my_stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
앞에서 말했듯이, 한 obstack에 있는 메모리 블럭을 해제하면, 그
obstack에서 이 메모리 블럭 이후에 할당한 모든 메모리까지 다 해제된다는
것을 다시 한 번 기억하기 바랍니다.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;Growing Objects&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Obstack은 단계적으로 메모리 블럭을 할당할 수 있는 방법을
제공합니다. 예를 들어, 파일에서 한 token을 읽어서 메모리에 할당한다고
가정해 봅시다. 보통 token을 나타내는 문자열을 다 읽어오기 전에는,
(크기를 모르기 때문에) 메모리를 할당할 수 없습니다. 그러나 obstack을
쓰면, 조금씩 메모리를 얻어 쓰다가, 마지막에 크기를 알게 된 순간에
지금까지 얻어쓴 크기만큼 메모리를 할당할 수 있습니다. 이 기능은 특히,
크기를 모르는 text를 파일/네트웍에서 받아 처리하는 함수를 작성할 때
매우 쓸모있습니다.
&lt;/p&gt;

&lt;p&gt;
growing object를 처리하는 함수들은 앞에서 설명한 함수들과는 조금 다른
방식으로 동작합니다. 먼저, 조금씩 얻어쓰는 단계에서는 마지막에 고정될
메모리의 주소를 알 수 없습니다. 즉, 얻어쓰는 단계에서 메모리의 위치가
바뀔 수도 있다는 뜻입니다. 표준 C 라이브러리가 제공하는 &lt;code&gt;realloc(3)&lt;/code&gt;⁠을
생각하시면 이해하기 쉬울 것입니다.
&lt;/p&gt;

&lt;p&gt;
한 obstack에서, growing object는 단 하나만 만들 수 있다는 것을 주의하기
바랍니다.
&lt;/p&gt;

&lt;p&gt;
growing object를 위해, 메모리를 할당하는 함수는 매우 많습니다. 여기서
적당한 것을 골라 쓰시면 되며, 여러번 부르거나 섞어써도 상관없습니다.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*       , SIZE          ,            */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;obstack_blank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* SIZE          , DATA                  */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;obstack_grow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;DATA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* obstack_grow()    ,   SIZE + 1          , &lt;/span&gt;
&lt;span class="cm"&gt; *      '\0'         . */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;obstack_grow0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;DATA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/*    C     */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;obstack_1grow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/*       DATA     */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;obstack_ptr_grow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;DATA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/*      DATA     */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;obstack_int_grow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;DATA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
따로 예제는 만들지 않겠습니다. 다만 &lt;code&gt;obstack_blank()&lt;/code&gt;⁠의 경우, 위에서
설명한 것 이외의 기능을 가지고 있습니다. 위 함수들을 써서 메모리를
조금씩 얻는 도중, 일정 크기의 메모리를 다시 반납하고 싶다면
&lt;code&gt;obstack_blank()&lt;/code&gt;⁠의 SIZE 파라메터에 음수값(negative value)을 주면
됩니다.
&lt;/p&gt;

&lt;p&gt;
그리고, 나중에 메모리의 크기를 확실히 알았다면, 이제 지금까지 얻어썼던
메모리를 고정(fix)시켜야 합니다. 이 역할은 &lt;code&gt;obstack_finish()&lt;/code&gt;⁠하며, 이
때에, 실제 메모리의 주소가 결정됩니다.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;obstack_finish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
만약, 얻어쓰는 도중에, (임시적으로 사용하고 있는) 메모리의 주소를 알고
싶다면, &lt;code&gt;osbtack_base()&lt;/code&gt;⁠를 쓰면 됩니다. 또, 현재 얻어쓰고 있는 메모리의
총 크기를 알고 싶다면 &lt;code&gt;obstack_object_size()&lt;/code&gt;⁠를 쓰면 됩니다. 만약
&lt;code&gt;obstack_object_size()&lt;/code&gt;⁠가 0을 리턴한다면 현재 얻어쓰고 있는 메모리가
없다는 뜻입니다. 주의할 것은, 만약 현재 얻어쓰고 있는 메모리가 없을
경우, &lt;code&gt;obstack_base()&lt;/code&gt;⁠가 &lt;code&gt;NULL&lt;/code&gt;⁠을 리턴하지 않는다는 것입니다. 얻어쓰고 있는
메모리가 없을 경우 &lt;code&gt;obstack_base()&lt;/code&gt;⁠는, 다음에 할당할 메모리 위치를
리턴합니다. 따라서, 현재 얻어쓰고 있는 메모리가 있느냐 여부는
&lt;code&gt;obstack_object_size()&lt;/code&gt;⁠로 알아내는 것이 좋습니다.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*    growing object  (   )               */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;obstack_base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/*    growing object       ,       0    */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;obstack_object_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OBSTACK_PTR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
마지막으로, growing object를 쓴 완전한 예제를 보고 끝내겠습니다. 표준
입력(stdin)에서 텍스트를 읽어서, 띄어쓰기 단위로 한 단어를 읽은 다음,
obstack에 할당하고, 이를 리턴하는 함수인 &lt;code&gt;get_word()&lt;/code&gt;⁠를 만들겠습니다.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;ctype.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;obstack.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#define obstack_chunk_alloc malloc&lt;/span&gt;
&lt;span class="cp"&gt;#define obstack_chunk_free  free&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="n"&gt;stack_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obstack&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;get_word&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/*    growing object          */&lt;/span&gt;
  &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obstack_object_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getchar&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="cm"&gt;/*           skip */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isspace&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isspace&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/*             EOF     growing object     */&lt;/span&gt;
    &lt;span class="n"&gt;obstack_1grow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getchar&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obstack_object_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/*             ,    */&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obstack_finish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stack_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;obstack_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_word&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"word: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;obstack_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;Memory Usage&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
Obstack은 내부적으로 블럭 단위(보통 4096 byte)로 메모리를 할당해서,
사용자가 요청할 때 쪼개어 보내줍니다. 따라서 동적으로 메모리가 할당되는
과정을 지켜보면 계단식으로 메모리가 요청된다는 것을 예상할 수
있습니다. 아래 그래프는 위 프로그램을 실행시켰을 때, 메모리가 할당되는
과정을 보여줍니다. (빨간색 선이 동적으로 할당되는 메모리 크기입니다)
&lt;/p&gt;

&lt;p&gt;
&lt;img src="http://www.cinsk.org/images/c-obstack-memusage.png" alt="nil"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-5" class="outline-2"&gt;
&lt;h2 id="sec-5"&gt;기타사항&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
이외에도 obstack은 여러가지 기능을 제공합니다. (이 글에서는 다루지
않겠지만) 관심있는 분은 &lt;a href="http://www.gnu.org/software/libc/manual/html_node/Obstacks.html#Obstacks"&gt;GNU C Library 매뉴얼&lt;/a&gt;을 찾아보기 바랍니다.
&lt;/p&gt;

&lt;p&gt;
obstack에 관련된 것 중 추가적으로 알려드리고 싶은 것들입니다:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;조금씩 할당해 쓰는 방식을 쓸 때, 더욱 빠르게 쓸 수 있는 방법이
있습니다. "Extra Fast Growing Object"란 것인데, 이는 메모리를 얻어쓸
때, obstack이 내부적으로 할당한 메모리 블럭의 크기를 넘지 않는다는
확신이 있을 때 사용합니다. 내부적으로 할당한 메모리 크기는
&lt;code&gt;obstack_room()&lt;/code&gt;⁠으로 확인할 수 있습니다.
&lt;/li&gt;
&lt;li&gt;일반적으로 &lt;code&gt;obstack_init()&lt;/code&gt;⁠을 호출하면, obstack은 먼저 커다란 메모리
블럭을 하나 할당하고 나서 시작합니다. 시스템에 따라 다르지만, 대개 이
크기는 4096 byte입니다. 만약, 이 초기 블럭의 크기가 너무 크다고
생각하면, (매뉴얼에는 나와 있지 않지만) &lt;code&gt;obstack_init()&lt;/code&gt; 대신에
&lt;code&gt;obstack_begin()&lt;/code&gt;⁠을 써서, 초기 크기가 적은 obstack을 만들 수
있습니다. (자세한 것은 obstack의 소스를 참고하기 바랍니다)
&lt;/li&gt;
&lt;li&gt;obstack이, 내부적으로 메모리를 할당하다가 메모리 부족 현상이 발생하면
에러를 리턴하지 않고, 에러 처리 함수를 호출합니다. 이 함수를
바꾸려면, 전역 함수 포인터인 &lt;code&gt;obstack_alloc_failed_handler&lt;/code&gt;⁠를 적당하게
바꿔주면 됩니다. 물론 이 함수 포인터를 적절하게 바꿔서, obstack 관련
모든 함수가 에러가 발생할 경우, 에러를 리턴하는 방식으로 wrapper를
만들 수도 있습니다.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>allocator</category><category>c</category><category>memory</category><category>obstack</category><guid>http://www.cinsk.org/ko/posts/c-obstack/index.html</guid><pubDate>Thu, 20 Jun 2013 03:06:00 GMT</pubDate></item><item><title>Preventing buffer overflows with strncpy, strncat, and snprintf</title><link>http://www.cinsk.org/ko/posts/c-overflow-strncpy-strncat-snprintf/index.html</link><dc:creator>Seong-Kook Shin</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Preventing Buffer overflows&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
흔히 버퍼 오퍼플로우를 막기 위해 쓰는 함수가, &lt;code&gt;strncpy(3)&lt;/code&gt;, &lt;code&gt;strncat(3)&lt;/code&gt;,
&lt;code&gt;snprintf(3)&lt;/code&gt;⁠입니다. 이들 함수는 버퍼의 크기를 미리 지정받아, 복사할
문자열의 길이가 버퍼의 크기보다 클 경우, 복사를 중지해서 버퍼를
벗어나는 복사를 막아줍니다. 하지만, 버퍼의 크기를 해석하는 방식이
약간씩 다르다는 것이 문제입니다.
&lt;/p&gt;

&lt;p&gt;
버퍼의 크기가 M이고, 복사해 넣을 문자열의 길이가 N이라고 합시다. 이 때
두 가지 경우를 생각할 수 있습니다. 첫째, 버퍼의 길이가 충분히 클 때
(즉, &lt;code&gt;M &amp;gt; N&lt;/code&gt;), 둘째 버퍼의 길이가 짧을 때 (즉 &lt;code&gt;M &amp;lt; N&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
이 함수들을 검사하기 위해, 먼저 주어진 버퍼의 내용을 그대로 출력해 주는
함수를 만들어 봅시다. 보통 C 언어가 제공하는 문자열 함수들은 '\0'을
만나면 출력을 멈추기 때문에, 버퍼의 내용 전체를 알아 보기에는 좋지
않습니다. 따라서 다음과 같이 버퍼의 내용을 전체 다 출력해 주는 함수를
만듭니다 (필요한 표준 헤더 파일은 생략합니다):
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;memdump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isprint&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'.'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
예를 들어 &lt;code&gt;char buf[10]&lt;/code&gt;⁠에 "ABCDEFGHI"가 들어있다고 가정하면,
&lt;code&gt;memdump(buf, 10)&lt;/code&gt;⁠은 다음과 같이 출력합니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ABCDEFGHI.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
이제, 각각의 함수가 앞에서 다룬 두 가지 경우에 어떤 식으로 동작하는지
살펴봅시다. 먼저 첫번째 경우 (버퍼가 충분히 클 경우)를 알아보는 코드는
다음과 같습니다 (&lt;code&gt;BUF_MAX&lt;/code&gt;⁠는 매크로이며 10입니다):
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;memdump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;strncpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;memdump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;strncat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;memdump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;snprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;memdump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
위 코드에서 문자열 "123"을 복사해 넣으면서, 버퍼의 길이는 5라고 치고 각
함수를 테스트합니다. 이 때, 출력은 다음과 같습니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;123.######
123..#####
123.######
123.######
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;strncpy(3)&lt;/code&gt;⁠를 제외하고, 나머지 세 함수는 예상대로 동작합니다. 즉 문자
'1', '2', '3'을 복사해 넣고, 문자열 끝을 알리는 '\0'까지 복사합니다. 이
네 문자 모두 버퍼의 길이라고 지정한 5보다 작기 때문에 문제는 전혀
없습니다. 하지만, 두번째 줄인 &lt;code&gt;strncpy(3)&lt;/code&gt;⁠는, 123을 복사해 넣고, 나머지
공간을 모두 '\0'으로 채운다는 것이 다릅니다! 즉, 버퍼가 충분히 클
경우에도, &lt;code&gt;strcpy(3)&lt;/code&gt;⁠와 &lt;code&gt;strncpy(3)&lt;/code&gt; 동작 방식은 서로 다릅니다!
&lt;/p&gt;

&lt;p&gt;
두번째 경우, 즉 버퍼가 충분히 크지 못할 경우를 살펴 봅시다. 이제
&lt;code&gt;strcpy(3)&lt;/code&gt;⁠의 경우, 테스트할 필요가 없으므로 뺐습니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;strncpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"12345"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;memdump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;strncat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"12345"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;memdump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;snprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"12345"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;memdump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUF_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
이 경우, 다음과 같은 출력을 얻을 수 있습니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;123#######
123.######
12.#######
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
세가지 함수 모두 다르게 동작한다는 것을 알 수 있습니다. 먼저
&lt;code&gt;strncpy(3)&lt;/code&gt;⁠의 경우, 버퍼의 길이가 부족할 경우, 버퍼의 크기만큼 써
줍니다. 이 때 공간이 부족하더라도 '\0'을 써 주지 않습니다. 따라서
&lt;code&gt;strncpy(3)&lt;/code&gt;⁠의 경우, 완전하지 못한 문자열을 얻을 수 있습니다.
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;strncat(3)&lt;/code&gt;⁠의 경우, 무조건 n개 문자를 복사합니다. 따라서 이 경우, 123을
복사한 다음 '\0'까지 써 줍니다. 사실 &lt;code&gt;strncat(3)&lt;/code&gt;⁠의 경우, 버퍼의 길이를
지정하는 것이 아니라, '\0'을 제외한 실제 복사할 문자의 갯수를 지정하는
것입니다.
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;snprintf(3)&lt;/code&gt;⁠의 경우, &lt;code&gt;strncat(3)&lt;/code&gt;⁠과 다르게, 버퍼의 크기를
지정합니다. 따라서 버퍼의 길이가 짧을 경우, 그 버퍼의 길이 - 1개의
문자를 복사하고, '\0'을 써 줍니다. 즉, &lt;code&gt;strncpy(3)&lt;/code&gt;⁠와 다르게, 어떤
경우에도 '\0'으로 끝나는 올바른 문자열을 만들어 줍니다.
&lt;/p&gt;

&lt;p&gt;
이제 이 차이를 알았으면, 실제 코드에서 어떤 식으로 써야 하는지
알아봅시다. 먼저 사용자가 입력한 문자열 some&lt;sub&gt;string이&lt;/sub&gt; 있다고 가정하고,
다음 코드를 보기 바랍니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;strncpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;some_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LEN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
자, 위 코드는 잘못된 코드입니다. 왜냐하면 some&lt;sub&gt;string의&lt;/sub&gt; 길이가 LEN보다
클 경우, buf에 들어가는 문자열이 '\0'으로 끝나지 않을 수 있기
때문입니다. 따라서 다음과 같이 써 주어야 합니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;strncpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;some_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LEN&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEN&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
다음 코드는 안전할까요?
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;strncat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;some_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LEN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
아닙니다. &lt;code&gt;strncat(3)&lt;/code&gt;⁠은, 버퍼의 크기가 아니라, 복사할 문자열의 길이를
지정하는 것이므로, 마찬가지로 '\0'으로 끝나지 않은 문자열을 만들
가능성이 있습니다.  이것도 다음과 같이 써야 합니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;strncat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;some_string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LEN&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEN&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
그럼 &lt;code&gt;snprintf(3)&lt;/code&gt;⁠를 쓴 코드를 봅시다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;snprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LEN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;some_string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
위 코드는 안전할까요? 예. 그렇습니다. 안전합니다. &lt;code&gt;snprintf(3)&lt;/code&gt;⁠는 버퍼의
길이를 받아서 어떤 상황에서도 '\0'으로 끝나는 완전한 문자열을 만들어
줍니다.
&lt;/p&gt;

&lt;p&gt;
안전한 프로그램, buffer overflow에 항상 신경써야 하는 코드를
작성한다면, 이와 같은 사항은 꼭 기억해 두어야 합니다. 그럼 이만.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>c</category><category>overflow</category><category>snprintf</category><category>strncat</category><category>strncpy</category><guid>http://www.cinsk.org/ko/posts/c-overflow-strncpy-strncat-snprintf/index.html</guid><pubDate>Wed, 20 Feb 2013 03:06:00 GMT</pubDate></item><item><title>Best buffer size to store pathnames, PATH_MAX</title><link>http://www.cinsk.org/ko/posts/c-pathmax/index.html</link><dc:creator>Seong-Kook Shin</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Buffer size to store pathnames&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
보통 filename (또는 file name)이라고 하면 어떤 파일 이름 그 자체를
나타냅니다 (예: "hello.c" 또는 "src") 그리고 pathname이라고 하면
filename 또는 이 파일의 위치 정보까지 포함된 문자열을 뜻합니다. (예:
"&lt;code&gt;/usr/bin&lt;/code&gt;", "&lt;code&gt;./a.out&lt;/code&gt;", "&lt;code&gt;/home/cinsk/.emacs&lt;/code&gt;" 등) 이 때 pathname은 보통
root 디렉토리에서 시작하느냐의 여부에 따라 absolute pathname
(절대경로) 또는 relative pathname (상대 경로)로 나타냅니다. Absolute
pathname의 경우, "/"로 시작하는 pathname입니다.
&lt;/p&gt;

&lt;p&gt;
파일 또는 디렉토리를 다루는 프로그램을 작성하다보면, filename이나
pathname을 취급할 경우가 많은데, 이 때 주어진 pathname을 저장하기
위해, 흔히 적당히 큰 문자 배열을 준비하고 쓰는 경우가 많습니다. 이런
식으로 작성한 프로그램은 적당히 크다고 생각한 값이 별로 크지 않을
경우, 버그가 발생할 수도 있으며, 나중에 수정하기도 꽤
어렵습니다. 따라서 이 경우에는 POSIX가 정의하고 있는
&lt;code&gt;PATH_MAX&lt;/code&gt;⁠란 상수를 쓰는 것이 바람직합니다.
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;PATH_MAX&lt;/code&gt;⁠는 패스 이름이 가질 수 있는 최대 글자 수를 나타냅니다. 패스
이름이란 디렉토리 이름을 포함한 파일 이름을 뜻합니다. (예:
"&lt;code&gt;/usr/bin/ls&lt;/code&gt;", "&lt;code&gt;/opt/share/info&lt;/code&gt;"). 문자열의 끝을 나타내는 '&lt;code&gt;\0&lt;/code&gt;'도
포함입니다. 따라서 정확히 파일이 가질 수 있는 글자 수의 총 길이는
&lt;code&gt;PATH_MAX - 1&lt;/code&gt;⁠이 됩니다.
&lt;/p&gt;

&lt;p&gt;
따라서 파일 이름을 처리하거나 저장할 경우, &lt;code&gt;PATH_MAX&lt;/code&gt;⁠ 크기의 메모리
공간을 준비해 놓고 작업하면 됩니다. 예를 들면 다음과 같습니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PATH_MAX&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
  &lt;span class="n"&gt;strncpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PATH_MAX&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
인생이 이렇게 단순했으면 얼마나 좋겠습니까만… 사실 이게 전부가 아닙니다.
&lt;/p&gt;

&lt;p&gt;
먼저, POSIX 호환 시스템이라 하더라도 &lt;code&gt;PATH_MAX&lt;/code&gt;⁠가 정의되어 있지 않은
경우가 있습니다.  왜 정의가 되어 있지 않냐면, 파일 이름의 길이 제한이
파일 시스템마다 달라질 수 있기 때문입니다.  예를 들어 무조건 한 파일
시스템만 사용하는 OS나, 여러 파일 시스템을 지원하더라도 파일 길이
제한의 값이 같은 OS라면 &lt;code&gt;PATH_MAX&lt;/code&gt;⁠가 정의되어 있습니다. 하지만, 만약 여러
파일 시스템을 지원하고, 또 각 파일 시스템마다 지원하는 최대 파일 이름
길이가 다르다면, 단순히 한 상수로 최대 파일 이름 길이를 나타낼 수
없습니다.
&lt;/p&gt;

&lt;p&gt;
또한, 드물지만, 파일 이름 길이에 제한이 없다면, &lt;code&gt;PATH_MAX&lt;/code&gt;⁠가 정의되어
있지 않습니다.
&lt;/p&gt;

&lt;p&gt;
둘째, &lt;code&gt;PATH_MAX&lt;/code&gt;⁠가 정의되어 있다 하더라도, 이 매크로가 배열의 크기로
쓰기에는 너무나 큰 상수일 가능성이 있습니다. 따라서 다음과 같이, 배열의
크기를 지정하는 목적으로 &lt;code&gt;PATH_MAX&lt;/code&gt;⁠를 쓰는 것은 별로 바람직한 방법은
아닙니다. (저도 여유가 없으면 자주 쓰는 방식이긴 하지만.. -_-;;)
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PATH_MAX&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
세째, &lt;code&gt;PATH_MAX&lt;/code&gt;⁠의 정확한 뜻에 관한 것입니다.  &lt;code&gt;PATH_MAX&lt;/code&gt;⁠는 임의의 한
pathname이 가질 수 있는 최대 값을 나타내는 것이 아닙니다. 다시 말해,
&lt;code&gt;PATH_MAX&lt;/code&gt;⁠보다 큰 pathname이 존재할 수도 있습니다. 여기에 관한 것은 바로
뒤에 pathconf(3)를 설명할 때 다루겠습니다.
&lt;/p&gt;

&lt;p&gt;
그럼 &lt;code&gt;PATH_MAX&lt;/code&gt;⁠가 정의되어 있지 않다면 어떻게 pathname의 최대값을 얻을 수
있느냐? 답은 pathconf(3)나 fpathconf(3)를 쓰는 것입니다.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;fpathconf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itn&lt;/span&gt; &lt;span class="n"&gt;filedes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;pathconf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
두 함수 모두, pathname에 관련된 정보를 얻는 목적으로 쓰이며,
fpathconf()는 이미 열려있는 file descriptor를, pathconf()는
파일/디렉토리 이름을 첫 인자로 받습니다. &lt;code&gt;PATH_MAX&lt;/code&gt;⁠의 값을 얻으려면 두
함수 모두 두번째 인자에 &lt;code&gt;_PC_PATH_MAX&lt;/code&gt;⁠를 주면 됩니다.
&lt;/p&gt;

&lt;p&gt;
왜 file descriptor나 파일/디렉토리 이름이 필요한지 궁금해 하는 분도
있을 것입니다. 그 이유는, 앞에서 잠깐 말했듯이, pathname의 최대값은
현재 파일 시스템에 따라 달라질 수 있기 때문에, 기준이 되는
파일/디렉토리 이름이 필요하기 때문입니다.
&lt;/p&gt;

&lt;p&gt;
이 두 함수 모두, 다른 정보를 얻기 위해 사용되기도 합니다. 예를 들어,
단순한 파일 이름의 최대값을 얻으려면 위 함수의 두번째 인자로
&lt;code&gt;_PC_NAME_MAX&lt;/code&gt;⁠를 사용합니다. 또 주어진 파일이 pipe (또는 FIFO)인 경우,
파이프 버퍼의 크기를 얻기 위해 &lt;code&gt;_PC_PIPE_BUF&lt;/code&gt;⁠를 쓸 수도 있습니다.
&lt;/p&gt;

&lt;p&gt;
한가지 주의할 것은 이 때 얻은 &lt;code&gt;PATH_MAX&lt;/code&gt;⁠ 값의 정확한 뜻입니다. 두 번째
인자로 &lt;code&gt;_PC_PATH_MAX&lt;/code&gt;⁠를 쓸 경우, 첫 번째 인자로 전달한 파일 이름이나
file descriptor는 반드시 디렉토리에 대한 이름 또는 file
descriptor이어야 합니다. 첫 번째 인자가 디렉토리를 가르킬 경우, 이 때
리턴한 값은 주어진 디렉토리를 기준으로한 상대 경로가 가질 수 있는 최대
길이를 뜻합니다. 만약 첫번째 인자가 디렉토리를 가리키지 않는다면, 리턴
값과 주어진 파일과 어떤 관계가 있다는 것을 보장할 수 없습니다. 또한
pathname의 길이에 대한 제한이 없는 경우, 이 두 함수는 -1을 리턴하고
errno를 설정하지 않습니다.
&lt;/p&gt;

&lt;p&gt;
추가적으로, POSIX는 &lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt;⁠란 매크로를 256으로 정의하고
있습니다. 그리고 &lt;code&gt;PATH_MAX&lt;/code&gt;⁠는 적어도 &lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt;⁠와 같거나 큰 값을
가져야한다고 정의합니다. 또 오래된 유닉스 시스템은 전통적으로
MAXPATHLEN이란 매크로를 쓰는 경우가 많습니다. (주의, 필자는
MAXPATHLEN의 정확한 뜻이나 유래에 대해 잘 모릅니다. 아시는 분은 제게
알려주시면 고맙겠습니다.)
&lt;/p&gt;

&lt;p&gt;
또, ISO C 표준은 파일 이름을 저장하기 위한 배열의 크기를 지정할
목적으로 &lt;code&gt;FILENAME_MAX&lt;/code&gt;⁠란 매크로를 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;⁠에 정의하고 있습니다. 이
매크로는 배열을 선언할 때 쓸 목적으로 만든 것이기 때문에 다음과 같이
쓰는 것이 가능합니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FILENAME_MAX&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
하지만, 사용가능한 파일의 최대 길이가 제한이 없는 경우라면, 문자 배열의
크기로 쓸만한 값을 &lt;code&gt;FILENAME_MAX&lt;/code&gt;⁠로 정의한다고 나와 있습니다. 따라서
파일의 최대 길이가 제한이 없는 경우라면 pathconf()나 fpathconf()를
써야만 알 수 있습니다. (errno 변경없이 -1을 리턴)
&lt;/p&gt;

&lt;p&gt;
따라서 이식성이 뛰어난 프로그램을 만들고 싶다면 다음과 같은 코드를 헤더
파일에 포함시키는 것도 좋을 것입니다:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;limits.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#ifndef _POSIX_PATH_MAX&lt;/span&gt;
&lt;span class="cp"&gt;#define _POSIX_PATH_MAX    256&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cp"&gt;#if !defined =PATH_MAX=  &amp;amp;&amp;amp; defined _PC_PATH_MAX&lt;/span&gt;
&lt;span class="cp"&gt;# define PATH_MAX    (pathconf("/", _PC_PATH_MAX) &amp;lt; 1 ? 1024 \&lt;/span&gt;
&lt;span class="cp"&gt;		      : pathconf("/", _PC_PATH_MAX))&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cp"&gt;#if !defined PATH_MAX &amp;amp;&amp;amp; defined MAXPATHLEN&lt;/span&gt;
&lt;span class="cp"&gt;# define PATH_MAX MAXPATHLEN&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cp"&gt;#if !defined PATH_MAX &amp;amp;&amp;amp; defined FILENAME_MAX&lt;/span&gt;
&lt;span class="cp"&gt;# define PATH_MAX FILENAME_MAX&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cp"&gt;#ifndef PATH_MAX&lt;/span&gt;
&lt;span class="cp"&gt;# define PATH_MAX _POSIX_PATH_MAX&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
물론 완벽한 것은 아닙니다. 사실 위 코드는 gnulib 패키지의 &amp;lt;pathmax.h&amp;gt;를
조금 손본 것이며, pathname 길이에 제한이 없는 경우는 고려하지
않았습니다.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
지금까지 내용을 요약해 보면,
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;pathname을 저장하기 위해, &lt;code&gt;PATH_MAX&lt;/code&gt;⁠를 쓰는 것은 바람직하나,
&lt;code&gt;PATH_MAX&lt;/code&gt;⁠보다 큰 pathname이 존재할 수도 있다는 것.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATH_MAX&lt;/code&gt;⁠를 쓸 경우, 동적으로 메모리를 할당하는 방식 (예: malloc()
함수)을 쓰는 것이 바람직하다는 것.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATH_MAX&lt;/code&gt;⁠는 마지막 '\0'도 포함한다는 것. 즉 &lt;code&gt;PATH_MAX&lt;/code&gt;⁠ + 1과 같은
형태로 쓸 필요가 없다는 것.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATH_MAX&lt;/code&gt;⁠가 정의되어 있지 않을 경우, pathconf(3) 또는 fpathconf(3)를
써서 &lt;code&gt;PATH_MAX&lt;/code&gt;⁠의 값을 얻을 수 있다는 것.
&lt;/li&gt;
&lt;li&gt;세번째 목적으로 pathconf(3)나 fpatconf(3)를 쓸 때, 첫번째 인자는
디렉토리를 가리키고 있어야 한다는 것입니다.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
마지막으로, &lt;code&gt;FILENAME_MAX&lt;/code&gt;⁠를 제외한 모든 매크로, 함수는 SUS 표준
(POSIX)이며, ISO C 표준에는 나와 있지 않다는 것을 말해 둡니다.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>c</category><category>filename_max</category><category>maxpathlen</category><category>pathmax</category><guid>http://www.cinsk.org/ko/posts/c-pathmax/index.html</guid><pubDate>Tue, 19 Feb 2013 05:40:00 GMT</pubDate></item></channel></rss>